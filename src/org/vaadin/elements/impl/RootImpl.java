package org.vaadin.elements.impl;

import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import org.jsoup.Jsoup;
import org.jsoup.nodes.Attribute;
import org.jsoup.nodes.Document;
import org.vaadin.elements.ElementIntegration;
import org.vaadin.elements.Node;
import org.vaadin.elements.Root;
import org.vaadin.elements.TextNode;

import com.vaadin.server.EncodeResult;
import com.vaadin.server.JsonCodec;
import com.vaadin.ui.Component;
import com.vaadin.ui.JavaScriptFunction;

import elemental.json.Json;
import elemental.json.JsonArray;
import elemental.json.JsonValue;

public class RootImpl extends ElementImpl implements Root {
    private ElementIntegration owner;

    private int callbackIdSequence = 0;
    private int nodeIdSequence = 1;
    private int fetchCallbackSequence = 0;

    private final Map<Node, Integer> nodeToId = new HashMap<>();
    private final Map<Integer, Node> idToNode = new HashMap<>();

    private JsonArray pendingCommands = Json.createArray();

    private final Map<Integer, Runnable> fetchDomCallbacks = new HashMap<>();
    private final Map<Integer, Component[]> fetchDomComponents = new HashMap<>();

    public RootImpl(ElementIntegration owner) {
        super(new org.jsoup.nodes.Element(org.jsoup.parser.Tag.valueOf("div"),
                ""));

        Context context = new Context() {
            @Override
            protected void adopt(NodeImpl node) {
                super.adopt(node);

                if (node != RootImpl.this) {
                    adoptNode(node);
                }
            }

            @Override
            protected void remove(NodeImpl node) {
                addCommand("remove", node);
                Integer id = nodeToId.remove(node);
                idToNode.remove(id);

                super.remove(node);
            }

            @Override
            public RootImpl getRoot() {
                return RootImpl.this;
            }
        };
        this.owner = owner;

        context.adopt(this);

        Integer ownId = Integer.valueOf(0);
        nodeToId.put(this, ownId);
        idToNode.put(ownId, this);
    }

    private void addCommand(String name, Node target, JsonValue... params) {
        assert target == null || target.getRoot() == this;

        JsonArray c = Json.createArray();
        c.set(0, name);

        if (target != null) {
            c.set(1, nodeToId.get(target).doubleValue());
        }

        Arrays.asList(params).forEach(p -> c.set(c.length(), p));

        pendingCommands.set(pendingCommands.length(), c);

        owner.markAsDirty();
    }

    private void adoptNode(Node child) {
        // Even numbers generated by server, odd by client
        nodeIdSequence += 2;
        Integer id = Integer.valueOf(nodeIdSequence);
        nodeToId.put(child, id);
        idToNode.put(id, child);

        // Enqueue initialization operations
        if (child instanceof ElementImpl) {
            ElementImpl e = (ElementImpl) child;

            addCommand("createElement", child, Json.create(e.getTag()));

            e.getAttributeNames().forEach(name -> setAttributeChange(e, name));
            e.flushEvals();
        } else if (child instanceof TextNodeImpl) {
            TextNode t = (TextNode) child;

            addCommand("createText", child, Json.create(t.getText()));
        } else {
            throw new RuntimeException("Unsupported node type: "
                    + child.getClass());
        }

        // Finally add append command
        addCommand("appendChild", child.getParent(),
                Json.create(id.doubleValue()));
    }

    void setAttributeChange(ElementImpl element, String name) {
        String value = element.getAttribute(name);
        if (value == null) {
            addCommand("removeAttribute", element, Json.create(name));
        } else {
            addCommand("setAttribute", element, Json.create(name),
                    Json.create(value));
        }
    }

    public JsonArray flushPendingCommands() {
        for (Entry<Integer, Component[]> entry : fetchDomComponents.entrySet()) {
            JsonArray connectorsJson = Json.createArray();
            for (Component component : entry.getValue()) {
                connectorsJson.set(connectorsJson.length(),
                        component.getConnectorId());
            }

            addCommand("fetchDom", null,
                    Json.create(entry.getKey().intValue()), connectorsJson);
        }
        fetchDomComponents.clear();

        JsonArray payload = pendingCommands;
        pendingCommands = Json.createArray();
        return payload;
    }

    void eval(ElementImpl element, String script, Object[] arguments) {
        // Param values
        JsonArray params = Json.createArray();

        // Array of param indices that should be treated as callbacks
        JsonArray callbacks = Json.createArray();

        for (int i = 0; i < arguments.length; i++) {
            Object value = arguments[0];
            Class<? extends Object> type = value.getClass();

            if (JavaScriptFunction.class.isAssignableFrom(type)) {
                // TODO keep sequence per element instead of "global"
                int cid = callbackIdSequence++;
                element.setCallback(cid, (JavaScriptFunction) value);

                value = Integer.valueOf(cid);
                type = Integer.class;

                callbacks.set(callbacks.length(), i);
            }

            EncodeResult encodeResult = JsonCodec.encode(value, null, type,
                    owner.getUI().getConnectorTracker());
            params.set(i, encodeResult.getEncodedValue());
        }

        addCommand("eval", element, Json.create(script), params, callbacks);
    }

    public void handleCallback(JsonArray arguments) {
        int elementId = (int) arguments.getNumber(0);
        int cid = (int) arguments.getNumber(1);
        JsonArray params = arguments.getArray(2);

        ElementImpl element = (ElementImpl) idToNode.get(Integer
                .valueOf(elementId));
        if (element == null) {
            System.out.println(cid + " detached?");
            return;
        }

        JavaScriptFunction callback = element.getCallback(cid);
        callback.call(params);
    }

    @Override
    public String asHtml() {
        StringBuilder b = new StringBuilder();

        b.append(super.asHtml());

        return b.toString();
    }

    public void init(String html) {
        // Clear state
        removeAllChildren();
        getAttributeNames().forEach(this::removeAttribute);

        nodeIdSequence = 2;

        Document bodyFragment = Jsoup.parseBodyFragment(html);
        List<org.jsoup.nodes.Node> childNodes = bodyFragment.body()
                .childNodes();
        assert childNodes.size() == 1;

        org.jsoup.nodes.Node rootNode = childNodes.get(0);

        while (rootNode.childNodeSize() != 0) {
            org.jsoup.nodes.Node child = rootNode.childNode(0);
            ((org.jsoup.nodes.Element) this.node).appendChild(child);
        }

        context.wrapChildren(this);

        for (Attribute a : rootNode.attributes()) {
            setAttribute(a.getKey(), a.getValue());
        }
        // Don't send the adopted structure to the client
        pendingCommands = Json.createArray();

        // TODO sync ids

        fetchDomCallbacks.values().forEach(Runnable::run);
        fetchDomCallbacks.clear();
    }

    @Override
    public void fetchDom(Runnable callback, Component... connectorsToInlcude) {
        assert callback != null;

        Integer id = Integer.valueOf(fetchCallbackSequence++);
        fetchDomCallbacks.put(id, callback);
        fetchDomComponents.put(id, connectorsToInlcude);
    }

}
